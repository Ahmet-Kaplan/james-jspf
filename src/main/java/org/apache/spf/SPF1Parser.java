/***********************************************************************
 * Copyright (c) 1999-2006 The Apache Software Foundation.             *
 * All rights reserved.                                                *
 * ------------------------------------------------------------------- *
 * Licensed under the Apache License, Version 2.0 (the "License"); you *
 * may not use this file except in compliance with the License. You    *
 * may obtain a copy of the License at:                                *
 *                                                                     *
 *     http://www.apache.org/licenses/LICENSE-2.0                      *
 *                                                                     *
 * Unless required by applicable law or agreed to in writing, software *
 * distributed under the License is distributed on an "AS IS" BASIS,   *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or     *
 * implied.  See the License for the specific language governing       *
 * permissions and limitations under the License.                      *
 ***********************************************************************/

package org.apache.spf;

import org.apache.spf.mechanismn.AMechanism;
import org.apache.spf.mechanismn.AllMechanism;
import org.apache.spf.mechanismn.Directive;
import org.apache.spf.mechanismn.ExistsMechanism;
import org.apache.spf.mechanismn.IP4Mechanism;
import org.apache.spf.mechanismn.IP6Mechanism;
import org.apache.spf.mechanismn.IncludeMechanism;
import org.apache.spf.mechanismn.MXMechanism;
import org.apache.spf.mechanismn.Mechanism;
import org.apache.spf.mechanismn.PTRMechanism;
import org.apache.spf.modifier.ExpModifier;
import org.apache.spf.modifier.Modifier;
import org.apache.spf.modifier.RedirectModifier;
import org.apache.spf.modifier.UnknownModifier;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class can be used ass parses for validate SPF1-Records. It also offer a
 * Collection of SPF1.Mechanism .
 * 
 * @author Norman Maurer <nm@byteaction.de>
 * @author Stefano Bagnara <apache@bago.org>
 */
public class SPF1Parser {

    private static final Class[] knownMechanisms = new Class[] {
            AllMechanism.class, 
            AMechanism.class, 
            ExistsMechanism.class,
            IncludeMechanism.class, 
            IP4Mechanism.class, 
            IP6Mechanism.class,
            MXMechanism.class, 
            PTRMechanism.class 
    };

    private static final Class[] knownModifiers = new Class[] {
            ExpModifier.class, 
            RedirectModifier.class, 
            UnknownModifier.class 
    };

    /**
     * Regex based on http://ftp.rfc-editor.org/in-notes/authors/rfc4408.txt.
     * This will be the next official SPF-Spec
     */

    // TODO: fix the Quantifier problem
    // What is the "Quantifier problem"?
    public static final String ALPHA_DIGIT_PATTERN = "[a-zA-Z0-9]";

    public static final String ALPHA_PATTERN = "[a-zA-Z]";

    private static final String MACRO_LETTER_PATTERN = "[lsoditpvhcrLSODITPVHCR]";

    private static final String TRANSFORMERS_REGEX = "\\d*[r]?";

    private static final String DELEMITER_REGEX = "[\\.\\-\\+,/_\\=]";

    public static final String MACRO_EXPAND_REGEX = "\\%(?:\\{"
            + MACRO_LETTER_PATTERN + TRANSFORMERS_REGEX + DELEMITER_REGEX + "*"
            + "\\}|\\%|\\_|\\-)";

    private static final String MACRO_LITERAL_REGEX = "[\\x21-\\x24\\x26-\\x7e]";

    /**
     * ABNF: macro-string = *( macro-expand / macro-literal )
     */
    public static final String MACRO_STRING_REGEX = "(?:" + MACRO_EXPAND_REGEX
            + "|" + MACRO_LITERAL_REGEX + "{1})*";

    /**
     * ABNF: qualifier = "+" / "-" / "?" / "~"
     */
    private static final String QUALIFIER_PATTERN = "[\\+\\-\\?\\~]";

//    /**
//     * ABNF: mechanism = ( all / include / A / MX / PTR / IP4 / IP6 / exists )
//     * AUTOGENERATED
//     */
//    private String MECHANISM_NAME_STEP_REGEX = null;
//
//    /**
//     * TODO check that MACRO_STRING_REGEX already include all the available
//     * chars in mechanism parameters
//     */
//    private static final String MECHANISM_VALUE_STEP_REGEX = MACRO_STRING_REGEX;

    /**
     * ABNF: toplabel = ( *alphanum ALPHA *alphanum ) / ( 1*alphanum "-" *(
     * alphanum / "-" ) alphanum ) ; LDH rule plus additional TLD restrictions ;
     * (see [RFC3696], Section 2)
     */
    private static final String TOP_LABEL_REGEX = "(?:"
            + SPF1Parser.ALPHA_DIGIT_PATTERN + "*" + SPF1Parser.ALPHA_PATTERN
            + "{1}" + SPF1Parser.ALPHA_DIGIT_PATTERN + "*|(?:"
            + SPF1Parser.ALPHA_DIGIT_PATTERN + "+" + "\\-" + "(?:"
            + SPF1Parser.ALPHA_DIGIT_PATTERN + "|\\-)*"
            + SPF1Parser.ALPHA_DIGIT_PATTERN + "))";

    /**
     * ABNF: domain-end = ( "." toplabel [ "." ] ) / macro-expand
     */
    private static final String DOMAIN_END_REGEX = "(?:\\." + TOP_LABEL_REGEX
            + "\\.?" + "|" + SPF1Parser.MACRO_EXPAND_REGEX + ")";

    /**
     * ABNF: domain-spec = macro-string domain-end
     */
    public static final String DOMAIN_SPEC_REGEX = "("
            + SPF1Parser.MACRO_STRING_REGEX + DOMAIN_END_REGEX + ")";

    private Pattern termsSeparatorPattern = null;

    
    private Pattern termPattern = null;

    
    // TODO: this should be automatically calculated 
    private static final int TERM_STEP_REGEX_QUALIFIER_POS = 1;

    private static final int TERM_STEP_REGEX_MECHANISM_POS = 2;

    private static final int TERM_STEP_REGEX_MODIFIER_POS = 16;

    private Pattern recordPattern = null;

    private Map mechanismsMap;

    private Map modifiersMap;

    /**
     * Constructor.
     * Creates all the values needed to run the parsing
     */
    public SPF1Parser() {
        
        mechanismsMap = createPatternMap(knownMechanisms, "REGEX");
        modifiersMap = createPatternMap(knownModifiers, "REGEX");
        /**
         * ABNF: mechanism = ( all / include / A / MX / PTR / IP4 / IP6 / exists )
         */
        String MECHANISM_REGEX = createRegex(mechanismsMap);
        //MECHANISM_NAME_STEP_REGEX = null;

        /**
         * ABNF: modifier = redirect / explanation / unknown-modifier
         */
        String MODIFIER_REGEX = "(" + createRegex(modifiersMap) + ")";

        /**
         * ABNF: directive = [ qualifier ] mechanism
         */
        String DIRECTIVE_REGEX = "(" + QUALIFIER_PATTERN + "?)(" + MECHANISM_REGEX
                + ")";

        /**
         * ABNF: ( directive / modifier )
         */
        String TERM_REGEX = "(?:" + DIRECTIVE_REGEX + "|" + MODIFIER_REGEX
                + ")";

        /**
         * ABNF: 1*SP
         */
        String TERMS_SEPARATOR_REGEX = "[ ]+";

        /**
         * ABNF: terms = *( 1*SP ( directive / modifier ) )
         */
        String TERMS_REGEX = "(?:" + TERMS_SEPARATOR_REGEX + TERM_REGEX + ")*";
        
        /**
         * ABNF: record = "vspf1" terms
         */
        String RECORD_REGEX = Pattern.quote(SPF1Utils.SPF_VERSION) + TERMS_REGEX;

        /**
         * ABNF: directive = [ qualifier ] mechanism
         * 
         * This is used for the step-by-step parser, don't change the groups!
         * 
         * 1) QUALIFIER 2) ALL 3) MECHANISM NAME 4) MECHANISM VALUE 5) MODIFIER NAME
         * 6) MODIFIER VALUE
         */
        //String TERM_STEP_REGEX = TERM_STEP_REGEX = "(?:(" + QUALIFIER_PATTERN + "{1})?(?:("
        //        + MECHANISM_NAME_STEP_REGEX + ")([\\:/]{1}"
        //        + MECHANISM_VALUE_STEP_REGEX + ")?)|(?:"
        //        + UnknownModifier.REGEX + "))";

        recordPattern = Pattern.compile(RECORD_REGEX);
        termsSeparatorPattern = Pattern.compile(TERMS_SEPARATOR_REGEX);
        termPattern = Pattern.compile(TERM_REGEX);
    }

    /**
     * Loop the classes searching for a String static field named staticFieldName
     * and create an OR regeex like this:
     * (?:FIELD1|FIELD2|FIELD3)
     * 
     * @param classes classes to analyze
     * @param staticFieldName static field to concatenate
     * @return regex
     */
    private String createRegex(Map commandMap) {
        StringBuffer modifierRegex = new StringBuffer();
        Collection c = commandMap.values();
        Iterator i = c.iterator();
        boolean first = true;
        while (i.hasNext()) {
            if (first) {
                modifierRegex.append("(?:");
                first = false;
            } else {
                modifierRegex.append("|");
            }
            Pattern pattern = (Pattern) i.next();
            modifierRegex.append(pattern.pattern());
        }
        modifierRegex.append(")");
        return modifierRegex.toString();
    }

    /**
     * @param classes classes to analyze
     * @param staticFieldName static field to concatenate
     * @return map <Class,Pattern>
     */
    private Map createPatternMap(Class[] classes, String staticFieldName) {
        Map m = new HashMap();
        for (int j = 0; j < classes.length; j++) {
            Class mechClass = classes[j];
            try {
                String reg = (String) mechClass.getField(staticFieldName).get(null);
                m.put(classes[j],Pattern.compile(reg));
            } catch (Exception e) {

            }
        }
        return m;
    }

    public SPF1Record parse(String spfRecord) throws PermErrorException,
            NoneException {

        SPF1Record result = new SPF1Record();

        // check the version "header"
        if (!spfRecord.startsWith(SPF1Utils.SPF_VERSION + " ")) {
            throw new NoneException("No valid SPF Record: " + spfRecord);
        }

        Matcher m = recordPattern.matcher(spfRecord);
        // if (!m.matches()) {
        // throw new PermErrorException("Not Parsable: " + spfRecord);
        // }

        // the previous check could be skipped once we'll finish the
        // step-by-step parsing
        // we could simply keep it to have an "extra" input check.

        // extract terms
        String[] terms = termsSeparatorPattern.split(
                spfRecord.replaceFirst(SPF1Utils.SPF_VERSION, ""));

        // cycle terms
        for (int i = 0; i < terms.length; i++)
            if (terms[i].length() > 0) {
                Matcher termMatcher = termPattern.matcher(terms[i]);
                if (!termMatcher.matches()) {
                    throw new PermErrorException("Term [" + terms[i]
                            + "] is not syntactically valid: "
                            + termPattern.pattern());
                }
                
                /* DEBUG
                System.out.println("######################"+termMatcher.groupCount());
                for (int k = 1; k < termMatcher.groupCount(); k++) {
                    System.out.println("#"+k+"] "+termMatcher.group(k));
                }
                */

                // true if we matched a modifier, false if we matched a
                // directive
                String modifierString = termMatcher
                        .group(TERM_STEP_REGEX_MODIFIER_POS);
                if (modifierString != null) {

                    Modifier mod = (Modifier) lookupAndCreateTerm(modifierString, modifiersMap);

                    if (mod.enforceSingleInstance()) {
                        Iterator it = result.getModifiers().iterator();
                        while (it.hasNext()) {
                            if (it.next().getClass().equals(mod.getClass())) {
                                throw new PermErrorException("More than one "
                                        + modifierString + " found in SPF-Record");
                            }
                        }
                    }

                    result.getModifiers().add(mod);

                } else {
                    // DIRECTIVE
                    String qualifier = termMatcher
                            .group(TERM_STEP_REGEX_QUALIFIER_POS);
                    String mechString = termMatcher
                            .group(TERM_STEP_REGEX_MECHANISM_POS);

                    Object mech = lookupAndCreateTerm(mechString, mechanismsMap);

                    result.getDirectives().add(
                            new Directive(getQualifier(qualifier),(Mechanism) mech));

                }

            }

        // further check. We should remove this if it never catches more errors
        // than the default one.
        if (!m.matches()) {
            throw new PermErrorException("Not Parsable: " + spfRecord);
        }

        return result;
    }

    /**
     * @param mechName
     * @param mechValue
     * @param mech
     * @param termDefs
     * @return
     * @throws PermErrorException
     */
    private Object lookupAndCreateTerm(String mechString, Map patternMap) throws PermErrorException {
        Object mech = null;
        Iterator i = patternMap.keySet().iterator();
        while (i.hasNext()) {
            Class c = (Class) i.next();
            Pattern p = (Pattern) patternMap.get(c);
            
            if (p.matcher(mechString).matches()) {
                mech = createTerm(mechString, c, (Pattern) patternMap.get(c));
            }
        }
        return mech;
    }

    /**
     * @param mechValue
     * @param mechClass
     * @return
     * @throws PermErrorException 
     */
    private Object createTerm(String mechValue, Class mechClass, Pattern pattern) throws PermErrorException  {
        
        try {
            Object term = mechClass.newInstance();
            if (term instanceof Configurable) {
                if (mechValue == null) {
                    mechValue = "";
                }
                if ((mechValue == null || mechValue.length() == 0)
                        && pattern.pattern().length() == 0) {
                    ((Configurable) term).config(null);
                } else {
       
                    Matcher matcher = pattern
                            .matcher(mechValue);
                    if (!matcher.matches()) {
                        throw new PermErrorException(
                                "Value does not match: "
                                        + pattern
                                                .pattern()
                                        + " " + mechValue);
                    }
                    ((Configurable) term).config(matcher.toMatchResult());
                }
            }
            return term;
        } catch (IllegalAccessException e) {
            throw new PermErrorException("Unexpected error creating term: "+e.getMessage());
        } catch (InstantiationException e) {
            throw new PermErrorException("Unexpected error creating term: "+e.getMessage());
        }
    }

    /**
     * Get the qualifier for the given mechanismn record. if none was specified
     * in the mechanismn record the qualifier for pass "+" will be used
     * 
     * @param mechRecord
     *            The mechanismn record
     * @return qualifier This qualifier will be used by the mechanismn classes
     *         for the result the return when match
     */
    private String getQualifier(String mechRecord) {
        if (mechRecord == null) {
            return SPF1Utils.PASS;
        } else if (mechRecord.startsWith(SPF1Utils.FAIL)) {
            return SPF1Utils.FAIL;
        } else if (mechRecord.startsWith(SPF1Utils.SOFTFAIL)) {
            return SPF1Utils.SOFTFAIL;
        } else if (mechRecord.startsWith(SPF1Utils.NEUTRAL)) {
            return SPF1Utils.NEUTRAL;
        } else {
            return SPF1Utils.PASS;
        }
    }

}
